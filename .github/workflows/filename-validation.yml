name: File Validator

on:
  pull_request:
    branches:
      - main

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Get changed & added files
        id: changes
        uses: tj-actions/changed-files@v35
        with:
          files: |
            daily/**
            weekly/**
            monthly/**
            yearly/**

      - name: Detect relevant files
        id: detect
        run: |
          FILES="${{ steps.changes.outputs.added_files }} ${{ steps.changes.outputs.modified_files }}"
          
          TARGET_FILES=""
          FOUND=false

          for f in $FILES; do
            if [[ "$f" == daily/* || "$f" == weekly/* || "$f" == monthly/* || "$f" == yearly/* ]]; then
              TARGET_FILES="$TARGET_FILES $f"
              FOUND=true
            fi
          done

          echo "FILES_TO_VALIDATE=$TARGET_FILES" >> $GITHUB_ENV
          echo "SHOULD_VALIDATE=$FOUND" >> $GITHUB_ENV

      - name: Skip validation when folders are not touched
        if: env.SHOULD_VALIDATE == 'false'
        run: |
          echo "No daily/weekly/monthly/yearly files changed â†’ Skipping validation."
          exit 0

      - name: Validate files
        if: env.SHOULD_VALIDATE == 'true'
        run: |
          TODAY="2025-11-28"
          ERR=""
          FILES="$FILES_TO_VALIDATE"

          LAST_SERIAL=$(git ls-tree -r main --name-only daily weekly monthly yearly \
            | sed 's/.*\///' \
            | grep -E "^[0-9]+" \
            | cut -d' ' -f1 \
            | sort -n | tail -1)

          [[ -z "$LAST_SERIAL" ]] && LAST_SERIAL=0
          EXPECT=$((LAST_SERIAL + 1))

          for file in $FILES; do
            base=$(basename "$file")
            name="${base%.csv}"

            if [[ "$base" != *.csv ]]; then
              echo "::error ::File '$base' must end with .csv"
              exit 1
            fi

            if [[ ! "$name" =~ ^([0-9]+)\ ([0-9]{4})\ ([0-9]+)_(day|week|month|year)\ ([A-Za-z]+)$ ]]; then
              echo "::error ::File '$base' name format invalid"
              exit 1
            fi

            SERIAL=${BASH_REMATCH[1]}
            YEAR=${BASH_REMATCH[2]}
            COUNT=${BASH_REMATCH[3]}
            EVENT=${BASH_REMATCH[4]}
            MONTH=${BASH_REMATCH[5]}

            if [[ "$SERIAL" -ne "$EXPECT" ]]; then
              echo "::error ::Invalid serial in '$base'. Expected $EXPECT"
              exit 1
            fi

            if (( YEAR < 2000 || YEAR > 2025 )); then
              echo "::error ::Invalid year '$YEAR' in '$base'"
              exit 1
            fi

            MONTH_LOWER=$(echo "$MONTH" | tr '[:upper:]' '[:lower:]')
            MONTH_NUM=$(date -d "$MONTH_LOWER 1" +%m 2>/dev/null)

            if [[ -z "$MONTH_NUM" ]]; then
              echo "::error ::Invalid month name '$MONTH' in '$base'"
              exit 1
            fi

            # DAILY
            if [[ "$file" == daily/* ]]; then
              DAY="$COUNT"
              DATE_STR="$YEAR-$MONTH_NUM-$DAY"

              if ! date -d "$DATE_STR" >/dev/null 2>&1; then
                echo "::error ::Invalid date in '$base'"
                exit 1
              fi

              if [[ "$DATE_STR" > "$TODAY" ]]; then
                echo "::error ::Future day '$DATE_STR' not allowed ('$base')"
                exit 1
              fi

              WEEKDAY=$(date -d "$DATE_STR" +%u)
              if (( WEEKDAY >= 6 )); then
                echo "::error ::Weekend date '$DATE_STR' not allowed ('$base')"
                exit 1
              fi
            fi

            # WEEKLY
            if [[ "$file" == weekly/* ]]; then
              if (( COUNT < 1 || COUNT > 5 )); then
                echo "::error ::Invalid week number '$COUNT' ('$base')"
                exit 1
              fi

              dupe=$(git ls-tree -r main --name-only weekly | grep "${YEAR} ${COUNT}_week" | wc -l)
              if (( dupe >= 1 )); then
                echo "::error ::Duplicate weekly record for $YEAR week-$COUNT ('$base')"
                exit 1
              fi
            fi

            # MONTHLY
            if [[ "$file" == monthly/* ]]; then
              if (( COUNT < 1 || COUNT > 12 )); then
                echo "::error ::Invalid month number '$COUNT' ('$base')"
                exit 1
              fi

              if (( YEAR == 2025 && COUNT > 11 )); then
                echo "::error ::Future month '$MONTH' not allowed ('$base')"
                exit 1
              fi

              dupe=$(git ls-tree -r main --name-only monthly | grep "${YEAR} ${COUNT}_month" | wc -l)
              if (( dupe >= 1 )); then
                echo "::error ::Duplicate monthly record for $YEAR month-$COUNT ('$base')"
                exit 1
              fi
            fi

            # YEARLY
            if [[ "$file" == yearly/* ]]; then
              if (( COUNT != 1 )); then
                echo "::error ::Yearly count must be 1 ('$base')"
                exit 1
              fi

              dupe=$(git ls-tree -r main --name-only yearly | grep "${YEAR} 1_year" | wc -l)
              if (( dupe >= 1 )); then
                echo "::error ::Duplicate yearly record for $YEAR ('$base')"
                exit 1
              fi
            fi

            EXPECT=$((EXPECT + 1))
          done

          echo "All validations passed successfully!"
